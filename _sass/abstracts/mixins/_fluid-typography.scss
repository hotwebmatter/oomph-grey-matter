
/// Deep getter to go into the $type-sizes array
/// @author jhogue
///
/// @require {map} $type-sizes
///
/// @require {function} type-of
/// @require {function} map-get
///
/// @param {String} Breakpoint map key name
/// @param {String} Element name [base]
///
/// @example scss - Usage
///    font-size: px(one-type-size('h1', 'x-large'));
///
/// @example css - Output
///    font-size: 31px;
///
@function one-type-size($element, $break: small) {
  @if type-of($type-sizes) != 'map' {
    @error 'A list named $type-sizes is undefined. [Function one-type-size()]';
  }
  @if type-of(map-get($type-sizes, $break)) != 'map' {
    @error 'Canâ€™t reach into $type-sizes to retreive the $break [#{$break}] map. [Function one-type-size()]';
  }
  $elementsize: map-get(map-get($type-sizes, $break), $element);
  @return $elementsize;
}


/// Use fluid-units() to output all sizes for a typographic element
/// @author jhogue
///
/// @require {map} $type-sizes
///
/// @require {function} type-of
/// @require {function} map-keys
/// @require {function} map-has-key
/// @require {function} nth
/// @require {function} length
/// @require {function} em
///
/// @require {function} bp
///
/// @require {mixin} one-type-size
/// @require {mixin} fluid-units
///
/// @param {String} Element name [base]
///
/// @example scss - Usage
///   @include one-element-size(h1);
///
/// @example css - Output
///   h1 {
///     font-size: 1.9375em;
///   }
///   @media (min-width: 30em) {
///     h1 {
///       font-size: calc(1.9375em + 0.8125 * (100vw - 30em) / 55);
///     }
///   }
///   @media (min-width: 85em) {
///     h1 {
///       font-size: calc(1.9375em + 0.8125 * 1em);
///     }
///   }
///
@mixin fluid-type-sizes($elem: 'base', $bootstrap: true) {
  @if type-of($type-sizes) != 'map' {
    @error 'A sass map named $type-sizes is undefined. [Mixin one-element-size()]';
  }

  // List only the keys from the $type-sizes list.
  // Expects only two. Only uses the first and last
  $keys: map-keys($type-sizes);
  $first-key: nth($keys, 1);
  $last-key: nth($keys, length($keys));

  // Type size as REM values but unitless
  $min-value: strip-unit(rem(one-type-size($elem, $first-key)));
  $max-value: strip-unit(rem(one-type-size($elem, $last-key)));

  // Use the keys to grab the corresponding breakpoints
  // Check for existence and naming convention first
  @if type-of($project-breakpoints) != 'map' {
    @error 'A list named $project-breakpoints is undefined. [Mixin one-element-size()]';
  }
  @if not map-has-key($project-breakpoints, $first-key) {
    @error 'Your $type-sizes map key "#{$first-key}" does not have a corresponding key in $project-breakpoints. [Mixin one-element-size()]';
  }
  @if not map-has-key($project-breakpoints, $last-key) {
    @error 'Your $type-sizes map key "#{$last-key}" does not have a corresponding key in $project-breakpoints. [Mixin one-element-size()]';
  }

  // We need the bp value to be expressed as REM but unitless
  $min-vw: strip-unit(rem(map-get($project-breakpoints, $first-key)));
  $max-vw: strip-unit(rem(map-get($project-breakpoints, $last-key)));
  $unit: 1rem;

  // Finally, use this mixin to set the base size and max size within the viewport range

  // If this is bootstrap, don't output the first default type size
  @if ($bootstrap == false) {
    font-size: calc(#{$min-value} * $unit);
  }

  // If both are the same value, don't output the media queries
  @if map-get(map-get($type-sizes, $first-key), $elem) != map-get(map-get($type-sizes, $last-key), $elem) {

    // Declare the creamy, fluid center using a media query at the min-width
    @media (min-width: #{$min-vw * $unit}) {
      font-size: calc((#{$min-value} * #{$unit}) + (#{$max-value} - #{$min-value}) * ((100vw - #{$min-vw * $unit}) / #{$max-vw - $min-vw}));
    }

    // Finally, stop the crazy fluidity and set the max value at the max viewport width
    @media (min-width: #{$max-vw * $unit}) {
      font-size: calc(#{$max-value} * #{$unit});
    }
  }
}
